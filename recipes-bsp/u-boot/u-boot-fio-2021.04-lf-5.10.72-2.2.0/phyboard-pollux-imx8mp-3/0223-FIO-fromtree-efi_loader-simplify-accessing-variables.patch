From 4cca33e917febb1f0bcc999940f59c144ee944a1 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Mon, 24 May 2021 11:10:59 +0200
Subject: [PATCH 223/322] [FIO fromtree] efi_loader: simplify accessing
 variables

Use efi_get_variable_int() instead of EFI_CALL(RT->get_variable()).
Use efi_set_variable_int() instead of EFI_CALL(efi_set_variable()).

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
Tested-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
Reviewed-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
(cherry picked from commit acfe1def3f147c20e116f479225546bc5e3bfc27)
Signed-off-by: Ricardo Salveti <ricardo@foundries.io>
---
 cmd/efidebug.c | 33 ++++++++++++++++++---------------
 1 file changed, 18 insertions(+), 15 deletions(-)

diff --git a/cmd/efidebug.c b/cmd/efidebug.c
index 9c3ba73d618..c6352719dd8 100644
--- a/cmd/efidebug.c
+++ b/cmd/efidebug.c
@@ -12,6 +12,7 @@
 #include <efi_load_initrd.h>
 #include <efi_loader.h>
 #include <efi_rng.h>
+#include <efi_variable.h>
 #include <exports.h>
 #include <hexdump.h>
 #include <log.h>
@@ -239,8 +240,9 @@ static int do_efi_capsule_res(struct cmd_tbl *cmdtp, int flag,
 	guid = efi_guid_capsule_report;
 	if (argc == 1) {
 		size = sizeof(var_name16);
-		ret = EFI_CALL(RT->get_variable(L"CapsuleLast", &guid, NULL,
-						&size, var_name16));
+		ret = efi_get_variable_int(L"CapsuleLast", &guid, NULL,
+					   &size, var_name16, NULL);
+
 		if (ret != EFI_SUCCESS) {
 			if (ret == EFI_NOT_FOUND)
 				printf("CapsuleLast doesn't exist\n");
@@ -263,13 +265,13 @@ static int do_efi_capsule_res(struct cmd_tbl *cmdtp, int flag,
 	}
 
 	size = 0;
-	ret = EFI_CALL(RT->get_variable(var_name16, &guid, NULL, &size, NULL));
+	ret = efi_get_variable_int(var_name16, &guid, NULL, &size, NULL, NULL);
 	if (ret == EFI_BUFFER_TOO_SMALL) {
 		result = malloc(size);
 		if (!result)
 			return CMD_RET_FAILURE;
-		ret = EFI_CALL(RT->get_variable(var_name16, &guid, NULL, &size,
-						result));
+		ret = efi_get_variable_int(var_name16, &guid, NULL, &size,
+					   result, NULL);
 	}
 	if (ret != EFI_SUCCESS) {
 		free(result);
@@ -1062,11 +1064,11 @@ static int do_efi_boot_add(struct cmd_tbl *cmdtp, int flag,
 		goto out;
 	}
 
-	ret = EFI_CALL(efi_set_variable(var_name16, &guid,
-					EFI_VARIABLE_NON_VOLATILE |
-					EFI_VARIABLE_BOOTSERVICE_ACCESS |
-					EFI_VARIABLE_RUNTIME_ACCESS,
-					size, data));
+	ret = efi_set_variable_int(var_name16, &guid,
+				   EFI_VARIABLE_NON_VOLATILE |
+				   EFI_VARIABLE_BOOTSERVICE_ACCESS |
+				   EFI_VARIABLE_RUNTIME_ACCESS,
+				   size, data, false);
 	if (ret != EFI_SUCCESS) {
 		printf("Cannot set %ls\n", var_name16);
 		r = CMD_RET_FAILURE;
@@ -1117,7 +1119,8 @@ static int do_efi_boot_rm(struct cmd_tbl *cmdtp, int flag,
 
 		efi_create_indexed_name(var_name16, sizeof(var_name16),
 					"Boot", id);
-		ret = EFI_CALL(efi_set_variable(var_name16, &guid, 0, 0, NULL));
+		ret = efi_set_variable_int(var_name16, &guid, 0, 0, NULL,
+					   false);
 		if (ret) {
 			printf("Cannot remove %ls\n", var_name16);
 			return CMD_RET_FAILURE;
@@ -1416,11 +1419,11 @@ static int do_efi_boot_next(struct cmd_tbl *cmdtp, int flag,
 
 	guid = efi_global_variable_guid;
 	size = sizeof(u16);
-	ret = EFI_CALL(efi_set_variable(L"BootNext", &guid,
+	ret = efi_set_variable_int(L"BootNext", &guid,
 					EFI_VARIABLE_NON_VOLATILE |
 					EFI_VARIABLE_BOOTSERVICE_ACCESS |
 					EFI_VARIABLE_RUNTIME_ACCESS,
-					size, &bootnext));
+					size, &bootnext, false);
 	if (ret != EFI_SUCCESS) {
 		printf("Cannot set BootNext\n");
 		r = CMD_RET_FAILURE;
@@ -1477,11 +1480,11 @@ static int do_efi_boot_order(struct cmd_tbl *cmdtp, int flag,
 	}
 
 	guid = efi_global_variable_guid;
-	ret = EFI_CALL(efi_set_variable(L"BootOrder", &guid,
+	ret = efi_set_variable_int(L"BootOrder", &guid,
 					EFI_VARIABLE_NON_VOLATILE |
 					EFI_VARIABLE_BOOTSERVICE_ACCESS |
 					EFI_VARIABLE_RUNTIME_ACCESS,
-					size, bootorder));
+					size, bootorder, true);
 	if (ret != EFI_SUCCESS) {
 		printf("Cannot set BootOrder\n");
 		r = CMD_RET_FAILURE;
-- 
2.34.1

