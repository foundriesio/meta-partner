From 20e5bf814f03a5a0de256d91948e6762015557f4 Mon Sep 17 00:00:00 2001
From: Ricardo Salveti <ricardo@foundries.io>
Date: Thu, 4 Feb 2021 00:12:06 -0300
Subject: [PATCH 085/322] [FIO extras] fiovb: add support to delete persistent
 values

Add command to allow deleting persistent values.

Signed-off-by: Ricardo Salveti <ricardo@foundries.io>
---
 cmd/fiovb.c                  | 31 ++++++++++++++++++++++++++++++
 common/fiovb.c               | 37 ++++++++++++++++++++++++++++++++++++
 include/fiovb.h              |  6 ++++++
 include/tee.h                |  1 +
 include/tee/optee_ta_fiovb.h |  7 +++++++
 5 files changed, 82 insertions(+)

diff --git a/cmd/fiovb.c b/cmd/fiovb.c
index b782794cc59..42b03ebe049 100644
--- a/cmd/fiovb.c
+++ b/cmd/fiovb.c
@@ -113,10 +113,40 @@ int do_fiovb_write_pvalue(cmd_tbl_t *cmdtp, int flag, int argc,
 	return CMD_RET_FAILURE;
 }
 
+int do_fiovb_delete_pvalue(cmd_tbl_t *cmdtp, int flag, int argc,
+			   char * const argv[])
+{
+	const char *name;
+	char fiovb_name[20] = { 0 }; /* fiovb.name */
+
+	if (!fiovb_ops) {
+		printf("Foundries.IO Verified Boot is not initialized, run 'fiovb init' first\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
+	name = argv[1];
+
+	if (fiovb_ops->delete_persistent_value(fiovb_ops, name) ==
+	    FIOVB_IO_RESULT_OK) {
+		printf("Deleted persistent value %s\n", name);
+		snprintf(fiovb_name, sizeof(fiovb_name), "fiovb.%s", name);
+		env_set(fiovb_name, NULL);
+		return CMD_RET_SUCCESS;
+	}
+
+	printf("Failed to delete persistent value\n");
+
+	return CMD_RET_FAILURE;
+}
+
 static cmd_tbl_t cmd_fiovb[] = {
 	U_BOOT_CMD_MKENT(init, 2, 0, do_fiovb_init, "", ""),
 	U_BOOT_CMD_MKENT(read_pvalue, 3, 0, do_fiovb_read_pvalue, "", ""),
 	U_BOOT_CMD_MKENT(write_pvalue, 3, 0, do_fiovb_write_pvalue, "", ""),
+	U_BOOT_CMD_MKENT(delete_pvalue, 2, 0, do_fiovb_delete_pvalue, "", ""),
 };
 
 static int do_fiovb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
@@ -144,4 +174,5 @@ U_BOOT_CMD(
 	"init <dev> - initialize fiovb for <dev>\n"
 	"read_pvalue <name> <bytes> - read a persistent value <name>\n"
 	"write_pvalue <name> <value> - write a persistent value <name>\n"
+	"delete_pvalue <name> - delete a persistent value <name>\n"
 	);
diff --git a/common/fiovb.c b/common/fiovb.c
index b951dd3f11a..bd6730f50ed 100644
--- a/common/fiovb.c
+++ b/common/fiovb.c
@@ -60,6 +60,8 @@ static fiovb_io_result invoke_func(struct fiovb_ops_data *ops_data, u32 func,
 		return FIOVB_IO_RESULT_ERROR_INSUFFICIENT_SPACE;
 	case TEE_ERROR_ITEM_NOT_FOUND:
 		return FIOVB_IO_RESULT_ERROR_NO_SUCH_VALUE;
+	case TEE_ERROR_ACCESS_CONFLICT:
+		return FIOVB_IO_RESULT_ERROR_ACCESS_CONFLICT;
 	case TEE_ERROR_TARGET_DEAD:
 		/*
 		 * The TA has paniced, close the session to reload the TA
@@ -191,6 +193,40 @@ free_name:
 	return rc;
 }
 
+static fiovb_io_result delete_persistent_value(struct fiovb_ops *ops,
+					       const char *name)
+{
+	fiovb_io_result rc;
+	struct tee_shm *shm_name;
+	struct tee_param param[1];
+	struct udevice *tee;
+	size_t name_size = strlen(name) + 1;
+
+	if (get_open_session(ops->user_data))
+		return FIOVB_IO_RESULT_ERROR_IO;
+
+	tee = ((struct fiovb_ops_data *)ops->user_data)->tee;
+
+	rc = tee_shm_alloc(tee, name_size,
+			   TEE_SHM_ALLOC, &shm_name);
+	if (rc)
+		return FIOVB_IO_RESULT_ERROR_OOM;
+
+	memcpy(shm_name->addr, name, name_size);
+
+	memset(param, 0, sizeof(param));
+	param[0].attr = TEE_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	param[0].u.memref.shm = shm_name;
+	param[0].u.memref.size = name_size;
+
+	rc = invoke_func(ops->user_data, TA_FIOVB_CMD_DELETE_PERSIST_VALUE,
+			 1, param);
+
+	tee_shm_free(shm_name);
+
+	return rc;
+}
+
 struct fiovb_ops *fiovb_ops_alloc(int boot_device)
 {
 	struct fiovb_ops_data *ops_data;
@@ -201,6 +237,7 @@ struct fiovb_ops *fiovb_ops_alloc(int boot_device)
 
 	ops_data->ops.user_data = ops_data;
 
+	ops_data->ops.delete_persistent_value = delete_persistent_value;
 	ops_data->ops.write_persistent_value = write_persistent_value;
 	ops_data->ops.read_persistent_value = read_persistent_value;
 	ops_data->mmc_dev = boot_device;
diff --git a/include/fiovb.h b/include/fiovb.h
index c80890b757f..5733cd1a156 100644
--- a/include/fiovb.h
+++ b/include/fiovb.h
@@ -18,6 +18,8 @@
  *      				     expected size.
  * FIOVB_IO_RESULT_ERROR_INSUFFICIENT_SPACE: buffer too small for the requested
  *					     operation.
+ * FIOVB_IO_RESULT_ERROR_ACCESS_CONFLICT: persistent object already exists and
+ *					  no permission to overwrite.
  */
 typedef enum {
 	FIOVB_IO_RESULT_OK,
@@ -26,6 +28,7 @@ typedef enum {
 	FIOVB_IO_RESULT_ERROR_NO_SUCH_VALUE,
 	FIOVB_IO_RESULT_ERROR_INVALID_VALUE_SIZE,
 	FIOVB_IO_RESULT_ERROR_INSUFFICIENT_SPACE,
+	FIOVB_IO_RESULT_ERROR_ACCESS_CONFLICT,
 } fiovb_io_result;
 
 struct fiovb_ops;
@@ -44,6 +47,9 @@ struct fiovb_ops {
                                             const char* name,
                                             size_t value_size,
                                             const uint8_t* value);
+
+  fiovb_io_result (*delete_persistent_value)(struct fiovb_ops* ops,
+                                             const char* name);
 };
 
 struct fiovb_ops_data {
diff --git a/include/tee.h b/include/tee.h
index 99367b258e2..9fbb95aca28 100644
--- a/include/tee.h
+++ b/include/tee.h
@@ -39,6 +39,7 @@
 #define TEE_SUCCESS			0x00000000
 #define TEE_ERROR_STORAGE_NOT_AVAILABLE	0xf0100003
 #define TEE_ERROR_GENERIC		0xffff0000
+#define TEE_ERROR_ACCESS_CONFLICT	0xffff0003
 #define TEE_ERROR_BAD_PARAMETERS	0xffff0006
 #define TEE_ERROR_ITEM_NOT_FOUND	0xffff0008
 #define TEE_ERROR_NOT_IMPLEMENTED	0xffff0009
diff --git a/include/tee/optee_ta_fiovb.h b/include/tee/optee_ta_fiovb.h
index fe7cab92097..beb945b0703 100644
--- a/include/tee/optee_ta_fiovb.h
+++ b/include/tee/optee_ta_fiovb.h
@@ -26,4 +26,11 @@
  */
 #define TA_FIOVB_CMD_WRITE_PERSIST_VALUE	1
 
+/*
+ * Delete a persistent object corresponding to the given name.
+ *
+ * in	params[0].memref:	persistent value name
+ */
+#define TA_FIOVB_CMD_DELETE_PERSIST_VALUE	2
+
 #endif /*__TA_FIOVB_H*/
-- 
2.34.1

