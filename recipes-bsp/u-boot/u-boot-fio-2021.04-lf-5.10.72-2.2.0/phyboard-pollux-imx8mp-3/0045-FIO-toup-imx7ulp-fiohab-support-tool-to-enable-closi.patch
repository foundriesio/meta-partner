From 22383533c95a5a82d89b2cbd5c5fa50eb26d71de Mon Sep 17 00:00:00 2001
From: Jorge Ramirez-Ortiz <jorge@foundries.io>
Date: Fri, 29 Nov 2019 20:59:57 +0100
Subject: [PATCH 045/322] [FIO toup] imx7ulp: fiohab: support tool to enable
 closing the device

The UUU script should look as follows (ie, pass the SRK keys for the
platform)

   uuu_version 1.0.1
   SDP: boot -f SPL-aeler-imx7ulpea-ucom -dcdaddr 0x2f010000 -cleardcd
   SDPU: delay 1000
   SDPU: write -f u-boot-aeler-imx7ulpea-ucom.itb
   SDPU: jump

   FB: ucmd setenv srk_0 0xEA2F0B50
   FB: ucmd setenv srk_1 0x871167F7
   FB: ucmd setenv srk_2 0xF5CECF5D
   FB: ucmd setenv srk_3 0x364727C3
   FB: ucmd setenv srk_4 0x8DD52832
   FB: ucmd setenv srk_5 0xF158F65F
   FB: ucmd setenv srk_6 0xA71BBE78
   FB: ucmd setenv srk_7 0xA3AD024A
   FB: ucmd if fiohab_close; then echo Platform Secured; \
       else echo Can Not Secure the Platform; fi
   FBK: DONE

Signed-off-by: Jorge Ramirez-Ortiz <jorge@foundries.io>

[FIO toup] fiohab: mx7ulp: validate the M4 fuses

Validate the M4 fuses before closing the board (not only the A7 ones)

Signed-off-by: Jorge Ramirez-Ortiz <jorge@foundries.io>

[FIO internal] fihab: do not close the board when RPMB is ready

On CAAM enabled hardware, open boards use test keys (not the OTPMK).
So if RPMB was provisioned before closing, the partitions would become
unavailable after close.

Signed-off-by: Jorge Ramirez-Ortiz <jorge@foundries.io>
---
 arch/arm/mach-imx/Makefile |   2 +-
 arch/arm/mach-imx/fiohab.c | 179 +++++++++++++++++++++++++++++++++++++
 2 files changed, 180 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/mach-imx/fiohab.c

diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
index a95d13b7fe3..0b42bf716b9 100644
--- a/arch/arm/mach-imx/Makefile
+++ b/arch/arm/mach-imx/Makefile
@@ -66,7 +66,7 @@ obj-$(CONFIG_IMX_TRUSTY_OS) += trusty.o
 endif
 ifeq ($(SOC),$(filter $(SOC),mx7ulp))
 obj-y  += cache.o mmdc_size.o
-obj-$(CONFIG_IMX_HAB) += hab.o
+obj-$(CONFIG_IMX_HAB) += hab.o fiohab.o
 endif
 ifeq ($(SOC),$(filter $(SOC),vf610))
 obj-y += ddrmc-vf610.o
diff --git a/arch/arm/mach-imx/fiohab.c b/arch/arm/mach-imx/fiohab.c
new file mode 100644
index 00000000000..4accc2f07f8
--- /dev/null
+++ b/arch/arm/mach-imx/fiohab.c
@@ -0,0 +1,179 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Foundries.IO
+ */
+
+#include <common.h>
+#include <config.h>
+#include <fuse.h>
+#include <mapmem.h>
+#include <image.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/hab.h>
+
+#if defined(CONFIG_FIOVB) && !defined(CONFIG_SPL_BUILD)
+#include <fiovb.h>
+#include <mmc.h>
+
+static struct mmc *init_mmc_device(int dev, bool force_init)
+{
+	struct mmc *mmc;
+
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		printf("no mmc device at slot %x\n", dev);
+		return NULL;
+	}
+
+	if (mmc_init(mmc)) {
+		printf("cant initialize mmc at slot %x\n", dev);
+		return NULL;
+	}
+
+	return mmc;
+}
+
+static int fiovb_provisioned(void)
+{
+	char len_str[32] = { '\0' };
+	struct fiovb_ops *sec;
+	int ret;
+
+	if (!init_mmc_device(0, false)) {
+		printf("Cant init MMC - RPMB not available\n");
+		return -1;
+	}
+
+	sec = fiovb_ops_alloc(0);
+	if (!sec) {
+		printf("Not enough memory to allocate ops\n");
+		return -ENOMEM;
+	}
+
+	snprintf(len_str, sizeof(len_str), "%ld", (unsigned long) 0);
+	ret = sec->write_persistent_value(sec, "m4size", strlen(len_str) + 1,
+					 (uint8_t *) len_str);
+	fiovb_ops_free(sec);
+
+	/* if the RPMB is accessible, then we can't close the device */
+	if (ret == FIOVB_IO_RESULT_OK) {
+		printf("Error, rpmb provisioned with test keys\n");
+		return -1;
+	}
+
+	return 0;
+}
+#else
+static int fiovb_provisioned(void)
+{
+	printf("RPMB provisioned check stubbed out !!\n");
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MX7ULP
+#define SRK_FUSE_LIST								\
+{ 5, 0 }, { 5, 1 }, { 5, 2}, { 5, 3 }, { 5, 4 }, { 5, 5}, { 5, 6 }, { 5 ,7 },	\
+{ 6, 0 }, { 6, 1 }, { 6, 2}, { 6, 3 }, { 6, 4 }, { 6, 5}, { 6, 6 }, { 6 ,7 },
+#define SECURE_FUSE_BANK	(29)
+#define SECURE_FUSE_WORD	(6)
+#define SECURE_FUSE_VALUE	(0x80000000)
+#else
+#error "SoC not supported"
+#endif
+
+static hab_rvt_report_status_t *hab_check;
+
+static int hab_status(void)
+{
+	hab_check = (hab_rvt_report_status_t *) HAB_RVT_REPORT_STATUS;
+	enum hab_config config = 0;
+	enum hab_state state = 0;
+
+	if (hab_check(&config, &state) != HAB_SUCCESS) {
+		printf("HAB events active error\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+/* The fuses must have been programmed and their values set in the environment.
+ * The fuse read operation returns a shadow value so a board reset is required
+ * after the SRK fuses have been written.
+ *
+ * On CAAM enabled boards (imx7, imx6 and others), the board should not be closed
+ * if RPMB keys have been provisioned as it would render it unavailable
+ * afterwards
+ */
+static int do_fiohab_close(cmd_tbl_t *cmdtp, int flag, int argc,
+			   char *const argv[])
+{
+	struct srk_fuse {
+		u32 bank;
+		u32 word;
+	} const srk_fuses[] = { SRK_FUSE_LIST };
+	char fuse_name[20] = { '\0' };
+	uint32_t fuse, fuse_env;
+	int i, ret;
+
+	if (argc != 1) {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+
+	/* if secure boot is already enabled, there is nothing to do */
+	if (imx_hab_is_enabled()) {
+		printf("secure boot already enabled\n");
+		return 0;
+	}
+
+	/* if RPMB can be accessed, we cant close the board */
+	ret = fiovb_provisioned();
+	if (ret)
+		return 1;
+
+	/* if there are pending HAB errors, we cant close the board */
+	if (hab_status())
+		return 1;
+
+	for (i = 0; i < ARRAY_SIZE(srk_fuses); i++) {
+		ret = fuse_read(srk_fuses[i].bank, srk_fuses[i].word, &fuse);
+		if (ret) {
+			printf("Secure boot fuse read error\n");
+			return 1;
+		}
+
+		/**
+		 * if the fuses are not in in the environemnt or hold the wrong
+		 * values, then we cant close the board
+		 */
+		sprintf(fuse_name, "srk_%d", i);
+		fuse_env = (uint32_t) env_get_hex(fuse_name, 0);
+		if (!fuse_env) {
+			printf("%s not in environment\n", fuse_name);
+			return 1;
+		}
+
+		if (fuse_env != fuse) {
+			printf("%s - programmed: 0x%x != expected: 0x%x \n",
+				fuse_name, fuse, fuse_env);
+			return 1;
+		}
+	}
+
+	ret = fuse_prog(SECURE_FUSE_BANK, SECURE_FUSE_WORD, SECURE_FUSE_VALUE);
+	if (ret) {
+		printf("Error writing the Secure Fuse\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(fiohab_close, CONFIG_SYS_MAXARGS, 1, do_fiohab_close,
+	   "Close the board for HAB","");
+
-- 
2.34.1

