From a52368bf07521ee5f630e04ebcab142bd0219756 Mon Sep 17 00:00:00 2001
From: Jorge Ramirez-Ortiz <jorge@foundries.io>
Date: Fri, 29 Nov 2019 20:59:57 +0100
Subject: [PATCH 022/233] [FIO toup] arch: mach-imx: fiohab: support tool to
 enable closing the device

Supports: mx7ulp, mx6, mx8mm, mx8qm (ahab).

How to use:
The UUU script should look as follows (ie, pass the SRK keys for the
platform)

   uuu_version 1.0.1
   SDP: boot -f SPL-aeler-imx7ulpea-ucom -dcdaddr 0x2f010000 -cleardcd
   SDPU: delay 1000
   SDPU: write -f u-boot-aeler-imx7ulpea-ucom.itb
   SDPU: jump

   FB: ucmd setenv srk_0 0xEA2F0B50
   FB: ucmd setenv srk_1 0x871167F7
   FB: ucmd setenv srk_2 0xF5CECF5D
   FB: ucmd setenv srk_3 0x364727C3
   FB: ucmd setenv srk_4 0x8DD52832
   FB: ucmd setenv srk_5 0xF158F65F
   FB: ucmd setenv srk_6 0xA71BBE78
   FB: ucmd setenv srk_7 0xA3AD024A
   FB: ucmd if fiohab_close; then echo Platform Secured; \
       else echo Can Not Secure the Platform; fi
   FBK: DONE

Notes:

mx7ulp:
- validate the M4 fuses before closing the board (not only the A7
  ones).

mx6:
- all of the i.MX6 processors use the same SRK_HASH and SEC_CONFIG[1]
  fuses to support secure boot.

fiohab:
- do not close the board when RPMB is ready. On CAAM enabled
  hardware, open boards use test keys (not the OTPMK). So if RPMB was
  provisioned before closing, the partitions would become unavailable
  after close.
- fiohab_dev variable is MANDATORY.
- we've added a fixed self-test into OP-TEE so it's safe to ignore
  the HAB event generated by RNG failed self-test for i.MX 6DQ and
  i.MX 6DL. (Patch based on work here:
  https://git.pengutronix.de/cgit/barebox/commit/drivers/hab/habv4.c?id=620cd45ac1b97fb0f5cf68be309c6f45cc53cc6a)
- supports AHAB.

Signed-off-by: Jorge Ramirez-Ortiz <jorge@foundries.io>
Co-developed-by: Michael Scott <mike@foundries.io>
Signed-off-by: Michael Scott <mike@foundries.io>
Co-developed-by: Vanessa Maegima <vanessa.maegima@foundries.io>
Signed-off-by: Vanessa Maegima <vanessa.maegima@foundries.io>
Co-developed-by: Ricardo Salveti <ricardo@foundries.io>
Signed-off-by: Ricardo Salveti <ricardo@foundries.io>
Co-developed-by: Igor Opaniuk <igor.opaniuk@foundries.io>
Signed-off-by: Igor Opaniuk <igor.opaniuk@foundries.io>
Co-developed-by: Oleksandr Suvorov <oleksandr.suvorov@foundries.io>
Signed-off-by: Oleksandr Suvorov <oleksandr.suvorov@foundries.io>
---
 arch/arm/mach-imx/Makefile |   8 +
 arch/arm/mach-imx/fiohab.c | 291 +++++++++++++++++++++++++++++++++++++
 2 files changed, 299 insertions(+)
 create mode 100644 arch/arm/mach-imx/fiohab.c

diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
index 4ebf95d2b35..612efd4045a 100644
--- a/arch/arm/mach-imx/Makefile
+++ b/arch/arm/mach-imx/Makefile
@@ -67,6 +67,14 @@ ifeq ($(SOC),$(filter $(SOC),mx7ulp))
 obj-y  += cache.o mmdc_size.o
 obj-$(CONFIG_IMX_HAB) += hab.o
 endif
+ifneq ($(CONFIG_SPL_BUILD),y)
+ifeq ($(SOC),$(filter $(SOC),mx6 mx7ulp imx8m))
+obj-$(CONFIG_IMX_HAB) += fiohab.o
+endif
+ifeq ($(SOC),$(filter $(SOC),imx8))
+obj-$(CONFIG_AHAB_BOOT) += fiohab.o
+endif
+endif
 ifeq ($(SOC),$(filter $(SOC),vf610))
 obj-y += ddrmc-vf610.o
 obj-$(CONFIG_DDRMC_VF610_CALIBRATION) += ddrmc-vf610-calibration.o
diff --git a/arch/arm/mach-imx/fiohab.c b/arch/arm/mach-imx/fiohab.c
new file mode 100644
index 00000000000..33bbcc55c9b
--- /dev/null
+++ b/arch/arm/mach-imx/fiohab.c
@@ -0,0 +1,291 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Foundries.IO
+ */
+
+#if (defined(CONFIG_MX6Q) || defined(CONFIG_MX6DL) || defined(CONFIG_MX6QDL))
+#define CONFIG_CAAM_IGNORE_KNOWN_HAB_EVENTS 1
+#endif
+
+#include <common.h>
+#include <config.h>
+#include <fuse.h>
+#include <mapmem.h>
+#include <image.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/hab.h>
+#include <asm/mach-imx/sys_proto.h>
+
+#if defined(CONFIG_AHAB_BOOT)
+#include <asm/arch/sci/sci.h>
+#endif
+
+#if defined(CONFIG_FIOVB) && !defined(CONFIG_SPL_BUILD)
+#include <fiovb.h>
+#include <mmc.h>
+
+static struct mmc *init_mmc_device(int dev, bool force_init)
+{
+	struct mmc *mmc;
+
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		printf("no mmc device at slot %x\n", dev);
+		return NULL;
+	}
+
+	if (mmc_init(mmc)) {
+		printf("cant initialize mmc at slot %x\n", dev);
+		return NULL;
+	}
+
+	return mmc;
+}
+
+static int fiovb_provisioned(void)
+{
+	char len_str[32] = { '\0' };
+	struct fiovb_ops *sec;
+	int ret;
+	unsigned int fiohab_dev = env_get_ulong("fiohab_dev", 10, 0xFFUL);
+
+	if (fiohab_dev == 0xFFUL) {
+		printf("fiohab_dev var is not defined!\n");
+		return -EINVAL;
+	}
+
+	if (!init_mmc_device(fiohab_dev, false)) {
+		printf("Cant init MMC - RPMB not available\n");
+		return -1;
+	}
+
+	sec = fiovb_ops_alloc(fiohab_dev);
+	if (!sec) {
+		printf("Not enough memory to allocate ops\n");
+		return -ENOMEM;
+	}
+
+	snprintf(len_str, sizeof(len_str), "%ld", (unsigned long) 0);
+	ret = sec->write_persistent_value(sec, "m4size", strlen(len_str) + 1,
+					 (uint8_t *) len_str);
+	fiovb_ops_free(sec);
+
+	/* if the RPMB is accessible, then we can't close the device */
+	if (ret == FIOVB_IO_RESULT_OK) {
+		printf("Error, rpmb provisioned with test keys\n");
+		return -1;
+	}
+
+	return 0;
+}
+#else
+static int fiovb_provisioned(void)
+{
+	printf("RPMB provisioned check stubbed out !!\n");
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MX7ULP
+#define SRK_FUSE_LIST								\
+{ 5, 0 }, { 5, 1 }, { 5, 2}, { 5, 3 }, { 5, 4 }, { 5, 5}, { 5, 6 }, { 5 ,7 },	\
+{ 6, 0 }, { 6, 1 }, { 6, 2}, { 6, 3 }, { 6, 4 }, { 6, 5}, { 6, 6 }, { 6 ,7 },
+#define SECURE_FUSE_BANK	(29)
+#define SECURE_FUSE_WORD	(6)
+#define SECURE_FUSE_VALUE	(0x80000000)
+#elif CONFIG_ARCH_MX6
+#define SRK_FUSE_LIST								\
+{ 3, 0 }, { 3, 1 }, { 3, 2}, { 3, 3 }, { 3, 4 }, { 3, 5}, { 3, 6 }, { 3 ,7 },
+#define SECURE_FUSE_BANK	(0)
+#define SECURE_FUSE_WORD	(6)
+#define SECURE_FUSE_VALUE	(0x00000002)
+#elif CONFIG_IMX8MM
+#define SRK_FUSE_LIST								\
+{ 6, 0 }, { 6, 1 }, { 6, 2 }, { 6, 3 }, { 7, 0 }, { 7, 1 }, { 7, 2 }, { 7 , 3 },
+#define SECURE_FUSE_BANK	(1)
+#define SECURE_FUSE_WORD	(3)
+#define SECURE_FUSE_VALUE	(0x2000000)
+#elif CONFIG_IMX8QM
+#define SRK_FUSE_LIST								\
+{ 0, 722 }, { 0, 723 }, { 0, 724 }, { 0, 725 }, { 0, 726 }, { 0, 727 }, \
+{ 0, 728 }, { 0, 729 }, { 0, 730 }, { 0, 731 }, { 0, 732 }, { 0, 733 }, \
+{ 0, 734 }, { 0, 735 }, { 0, 736 }, { 0, 737 },
+#else
+#error "SoC not supported"
+#endif
+
+#if defined(CONFIG_AHAB_BOOT)
+static int hab_status(void)
+{
+	int err;
+	u8 idx = 0U;
+	u32 event;
+	u16 lc;
+
+	err = sc_seco_chip_info(-1, &lc, NULL, NULL, NULL);
+	if (err != SC_ERR_NONE) {
+		printf("Error in get lifecycle\n");
+		return -EIO;
+	}
+
+	err = sc_seco_get_event(-1, idx, &event);
+	while (err == SC_ERR_NONE) {
+		idx++;
+		err = sc_seco_get_event(-1, idx, &event);
+	}
+	/* No events */
+	if (idx == 0)
+		return 0;
+
+	return 1;
+}
+
+#else /* defined(CONFIG_AHAB_BOOT) */
+#ifdef CONFIG_CAAM_IGNORE_KNOWN_HAB_EVENTS
+#define RNG_FAIL_EVENT_SIZE 36
+/* Known HAB event from imx6d where RNG selftest failed due to ROM issue */
+static uint8_t habv4_known_rng_fail_events[][RNG_FAIL_EVENT_SIZE] = {
+	{ 0xdb, 0x00, 0x24, 0x42,  0x69, 0x30, 0xe1, 0x1d,
+	  0x00, 0x04, 0x00, 0x02,  0x40, 0x00, 0x36, 0x06,
+	  0x55, 0x55, 0x00, 0x03,  0x00, 0x00, 0x00, 0x00,
+	  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	  0x00, 0x00, 0x00, 0x01 },
+};
+
+static bool is_known_rng_fail_event(const uint8_t *data, size_t len)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(habv4_known_rng_fail_events); i++) {
+		if (memcmp(data, habv4_known_rng_fail_events[i],
+			   min_t(size_t, len, RNG_FAIL_EVENT_SIZE)) == 0) {
+			return true;
+		}
+	}
+
+	return false;
+}
+#endif
+
+static hab_rvt_report_status_t *hab_check;
+
+static int hab_status(void)
+{
+	hab_check = (hab_rvt_report_status_t *) HAB_RVT_REPORT_STATUS;
+	enum hab_config config = 0;
+	enum hab_state state = 0;
+
+	if (hab_check(&config, &state) != HAB_SUCCESS) {
+/* check to see if the only events are known failures */
+#ifdef CONFIG_CAAM_IGNORE_KNOWN_HAB_EVENTS
+		hab_rvt_report_event_t *hab_event_f;
+		hab_event_f =  (hab_rvt_report_event_t *)HAB_RVT_REPORT_EVENT;
+		uint32_t index = 0; /* Loop index */
+		uint8_t event_data[128]; /* Event data buffer */
+		size_t bytes = sizeof(event_data); /* Event size in bytes */
+
+		/* Check for known failure to ingore */
+		while (hab_event_f(HAB_STS_ANY, index++, event_data, &bytes) ==
+		       HAB_SUCCESS) {
+			if (!is_known_rng_fail_event(event_data, bytes)) {
+				printf("HAB events active error\n");
+				printf("Make sure the SPL is correctly signed and the board is fused\n");
+				return 1;
+			}
+		}
+
+		printf("Ignoring known HAB failures, no other events found.\n");
+		return 0;
+#else
+		printf("HAB events active error\n");
+		printf("Make sure the SPL is correctly signed and the board is fused\n");
+		return 1;
+#endif
+	}
+
+	return 0;
+}
+#endif /* if defined(CONFIG_IMX8QM) */
+
+/* The fuses must have been programmed and their values set in the environment.
+ * The fuse read operation returns a shadow value so a board reset is required
+ * after the SRK fuses have been written.
+ *
+ * On CAAM enabled boards (imx7, imx6 and others), the board should not be closed
+ * if RPMB keys have been provisioned as it would render it unavailable
+ * afterwards
+ */
+static int do_fiohab_close(struct cmd_tbl *cmdtp, int flag, int argc,
+			   char *const argv[])
+{
+	struct srk_fuse {
+		u32 bank;
+		u32 word;
+	} const srk_fuses[] = { SRK_FUSE_LIST };
+	char fuse_name[20] = { '\0' };
+	uint32_t fuse, fuse_env;
+	int i, ret;
+
+	if (argc != 1) {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+
+	/* if secure boot is already enabled, there is nothing to do */
+	if (boot_mode_is_closed()) {
+		printf("secure boot already enabled\n");
+		return 0;
+	}
+
+	/* if RPMB can be accessed, we cant close the board */
+	ret = fiovb_provisioned();
+	if (ret)
+		return 1;
+
+	/* if there are pending HAB errors, we cant close the board */
+	if (hab_status())
+		return 1;
+
+	for (i = 0; i < ARRAY_SIZE(srk_fuses); i++) {
+		ret = fuse_read(srk_fuses[i].bank, srk_fuses[i].word, &fuse);
+		if (ret) {
+			printf("Secure boot fuse read error\n");
+			return 1;
+		}
+
+		/**
+		 * if the fuses are not in in the environemnt or hold the wrong
+		 * values, then we cant close the board
+		 */
+		sprintf(fuse_name, "srk_%d", i);
+		fuse_env = (uint32_t) env_get_hex(fuse_name, 0);
+		if (!fuse_env) {
+			printf("%s not in environment\n", fuse_name);
+			return 1;
+		}
+
+		if (fuse_env != fuse) {
+			printf("%s - programmed: 0x%x != expected: 0x%x \n",
+				fuse_name, fuse, fuse_env);
+			return 1;
+		}
+	}
+#if defined(CONFIG_IMX8QM)
+		ret = ahab_close();
+#else
+		ret = fuse_prog(SECURE_FUSE_BANK, SECURE_FUSE_WORD, SECURE_FUSE_VALUE);
+#endif
+	if (ret) {
+		printf("Error closing device");
+		return 1;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(fiohab_close, CONFIG_SYS_MAXARGS, 1, do_fiohab_close,
+	   "Close the board for HABv4/AHAB","");
+
-- 
2.40.1

